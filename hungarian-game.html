<!doctype html>
<html lang="hu">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Magyar sz√≥kirak√≥ ‚Ä¢ Hungarian Letter Game</title>
    <style>
      :root {
        --bg: #fdf5e6;
        --fg: #0f172a;
        --muted: #475569;
        --card: #ffffff;
        --accent: #f97316;
        --accent-2: #22c55e;
        --shadow: 0 18px 45px rgba(15, 23, 42, 0.12);
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: "Nunito", "Avenir Next", "Segoe UI", system-ui, -apple-system, sans-serif;
        background:
          radial-gradient(1200px 600px at 110% 0%, #ffe8d2 0%, transparent 60%),
          radial-gradient(900px 520px at -5% 110%, #dcfce7 0%, transparent 58%),
          var(--bg);
        color: var(--fg);
        min-height: 100vh;
      }

      a.back {
        position: fixed;
        inset-inline-start: 16px;
        inset-block-start: 16px;
        background: color-mix(in oklab, var(--fg) 10%, transparent);
        color: var(--fg);
        text-decoration: none;
        padding: 10px 14px;
        border-radius: 12px;
        font-weight: 800;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.15);
        z-index: 10;
      }

      main {
        max-width: 1100px;
        margin: 0 auto;
        padding: 48px 18px 64px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      header h1 {
        margin: 0 0 8px;
        font-size: clamp(32px, 5vw, 46px);
        letter-spacing: 0.4px;
      }
      header p { margin: 0 0 8px; color: var(--muted); }

      .panel {
        background: var(--card);
        border-radius: 18px;
        padding: 18px 20px;
        box-shadow: var(--shadow);
      }
      .panel-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        margin-bottom: 10px;
        font-weight: 800;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        font-size: 14px;
        color: #ef4444;
      }
      .panel-head .tag {
        padding: 4px 10px;
        border-radius: 999px;
        background: #fff7ed;
        color: #9a3412;
        font-size: 12px;
        font-weight: 800;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 999px;
        background: #fff7ed;
        color: #9a3412;
        font-size: 13px;
        font-weight: 800;
      }

      .length-control {
        background: #f8fafc;
        border: 2px solid #e2e8f0;
        border-radius: 14px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .length-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      .length-input {
        width: 100%;
        accent-color: var(--accent);
      }
      .length-note {
        margin: 0;
        color: var(--muted);
        font-size: 14px;
      }

      .toggle-grid, .keyboard {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
        gap: 10px;
        width: 100%;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: #f8fafc;
        border-radius: 12px;
        padding: 10px 12px;
        border: 2px solid transparent;
        cursor: pointer;
        font-weight: 700;
      }
      .toggle input {
        accent-color: var(--accent);
        width: 18px;
        height: 18px;
      }
      .toggle.active {
        border-color: color-mix(in oklab, var(--accent) 40%, transparent);
        box-shadow: 0 8px 16px rgba(249, 115, 22, 0.2);
      }

      .keyboard button {
        border: none;
        border-radius: 12px;
        padding: 12px 8px;
        background: #e0f2fe;
        color: #0f172a;
        font-weight: 800;
        font-size: 16px;
        cursor: pointer;
        box-shadow: 0 8px 14px rgba(14, 165, 233, 0.22);
        transition: transform 100ms ease, box-shadow 100ms ease, filter 120ms ease;
      }
      .keyboard button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 18px rgba(14, 165, 233, 0.25); }
      .keyboard button:active:not(:disabled) { transform: translateY(0); box-shadow: 0 6px 12px rgba(14, 165, 233, 0.18); }
      .keyboard button:disabled {
        background: #e2e8f0;
        color: #94a3b8;
        box-shadow: none;
        cursor: not-allowed;
      }

      .slots {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
        padding: 12px 4px;
        min-height: 72px;
      }
      .slot {
        min-width: 52px;
        min-height: 58px;
        border-radius: 12px;
        border: 3px solid #e2e8f0;
        display: grid;
        place-items: center;
        font-size: 26px;
        font-weight: 900;
        letter-spacing: 0.5px;
        background: #f8fafc;
        color: var(--fg);
      }
      .slot[data-state="right"] {
        border-color: var(--accent-2);
        background: #dcfce7;
        color: #14532d;
      }
      .slot[data-state="wrong"] {
        border-color: #f97316;
        background: #fff7ed;
        color: #9a3412;
      }

      .status {
        margin: 6px 0 0;
        color: var(--muted);
        font-weight: 700;
      }
      .status[data-tone="warn"] { color: #c2410c; }
      .status[data-tone="success"] { color: #15803d; }

      .actions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 12px;
      }
      .btn {
        border: none;
        border-radius: 12px;
        padding: 12px 16px;
        font-weight: 800;
        font-size: 16px;
        cursor: pointer;
        color: white;
        box-shadow: 0 10px 22px rgba(249, 115, 22, 0.25);
        background: linear-gradient(120deg, var(--accent), color-mix(in oklab, var(--accent) 40%, #fcd34d));
      }
      .btn.secondary {
        background: linear-gradient(120deg, #0ea5e9, #22c55e);
        box-shadow: 0 10px 22px rgba(34, 197, 94, 0.24);
      }
      .btn.ghost {
        background: #f8fafc;
        color: var(--fg);
        box-shadow: none;
        border: 2px solid #e2e8f0;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        box-shadow: none;
      }

      .hint {
        margin: 10px 0 0;
        color: var(--muted);
      }

      .word-input {
        width: 100%;
        min-height: 140px;
        border-radius: 12px;
        border: 2px solid #e2e8f0;
        background: #f8fafc;
        padding: 12px;
        font-size: 15px;
        font-family: inherit;
        resize: vertical;
      }
      .word-input:focus {
        outline: none;
        border-color: color-mix(in oklab, var(--accent) 45%, transparent);
        box-shadow: 0 10px 20px rgba(249, 115, 22, 0.15);
      }

      @media (max-width: 640px) {
        .keyboard button { padding: 12px 6px; font-size: 15px; }
        .toggle-grid { grid-template-columns: repeat(auto-fit, minmax(64px, 1fr)); }
        .toggle { padding: 10px 10px; }
        .slot { min-width: 44px; min-height: 50px; font-size: 22px; }
      }
    </style>
  </head>
  <body>
    <a class="back" href="index.html" aria-label="Vissza a f≈ëmen√ºbe">‚óÄ Vissza</a>
    <script src="magyar_szavak/words.js"></script>
    <main>
      <header>
        <h1>Magyar sz√≥kirak√≥</h1>
        <p>V√°laszd ki, melyik bet≈±kkel szeretn√©l gyakorolni. K√©rj egy √∫j sz√≥t, hallgasd meg, majd bet≈±nk√©nt √≠rd be a hi√°nyz√≥ helyekre.</p>
        <p class="hint">Ha minden bet≈± stimmel, nyert√©l ‚Äì j√∂het a k√∂vetkez≈ë sz√≥!</p>
      </header>

      <section class="panel" aria-labelledby="lettersTitle">
        <div class="panel-head">
          <span id="lettersTitle">Haszn√°lt bet≈±k</span>
          <span class="tag">Magyar √°b√©c√©</span>
        </div>
        <div id="toggleGrid" class="toggle-grid" role="group" aria-label="Bet≈±v√°laszt√≥"></div>
        <div class="length-control" aria-label="Maxim√°lis sz√≥hossz">
          <div class="length-head">
            <span>Max sz√≥hossz</span>
            <span id="maxLengthDisplay" class="pill">12 bet≈±</span>
          </div>
          <input
            id="maxLength"
            class="length-input"
            type="range"
            min="2"
            max="20"
            value="12"
            aria-label="Legfeljebb ennyi bet≈±s szavakat adjon a j√°t√©k"
          />
          <p class="length-note">A j√°t√©k csak legfeljebb ennyi bet≈±s sz√≥t v√°laszt.</p>
        </div>
        <div class="actions">
          <button id="generateBtn" class="btn" type="button">√öj sz√≥ k√©r√©se</button>
          <button id="speakBtn" class="btn secondary" type="button" disabled>üîä Mondd ki</button>
          <button id="resetSelection" class="btn ghost" type="button">√ñsszes bet≈± be</button>
          <button id="clearSelection" class="btn ghost" type="button">Minden bet≈± ki</button>
        </div>
        <p class="hint">Kapcsold ki azokat a bet≈±ket, amelyeket most nem szeretn√©l haszn√°lni. A j√°t√©k csak olyan sz√≥t ad, ami az enged√©lyezett bet≈±kb≈ël √°ll.</p>
      </section>

      <section class="panel" aria-labelledby="customTitle">
        <div class="panel-head">
          <span id="customTitle">Saj√°t sz√≥lista (opcion√°lis)</span>
          <span class="tag">TXT / JSON</span>
        </div>
        <p class="hint">Minden sor egy sz√≥, vagy adj meg egy JSON t√∂mb√∂t (pl. ["alma","sz√©k","t≈±z"]). Ha √ºresen hagyod, a be√©p√≠tett lista marad.</p>
        <textarea id="customList" class="word-input" placeholder="pl.:\nalma\nsz√©l\nsz√©k"></textarea>
        <div class="actions">
          <label for="wordFile" class="btn ghost" style="cursor: pointer; display: inline-flex; align-items: center; gap: 6px;">üìÇ F√°jl bet√∂lt√©se</label>
          <input type="file" id="wordFile" accept=".txt,.json,text/plain,application/json" hidden />
          <button id="applyCustom" class="btn" type="button">Saj√°t sz√≥lista haszn√°lata</button>
          <button id="clearCustom" class="btn ghost" type="button">Vissza a gy√°ri list√°ra</button>
        </div>
        <p id="customStatus" class="status">Ha nem adsz meg list√°t, a be√©p√≠tett szavak maradnak.</p>
      </section>

      <section class="panel" aria-live="polite">
        <div class="panel-head">
          <span>Aktu√°lis sz√≥</span>
          <span class="tag" id="lengthTag">0 bet≈±</span>
        </div>
        <div id="slots" class="slots" aria-label="Hi√°nyz√≥ bet≈±k">
          <span class="slot">_</span>
          <span class="slot">_</span>
          <span class="slot">_</span>
          <span class="slot">_</span>
        </div>
        <p id="status" class="status">V√°laszd ki a bet≈±ket, majd kattints az ‚Äû√öj sz√≥ k√©r√©se‚Äù gombra.</p>
        <div class="actions">
          <button id="revealBtn" class="btn ghost" type="button" disabled>Mutasd a sz√≥t</button>
        </div>
      </section>

      <section class="panel" aria-labelledby="keyboardTitle">
        <div class="panel-head">
          <span id="keyboardTitle">Bet≈±gombok</span>
          <span class="tag">√çrd be sorban</span>
        </div>
        <div id="keyboard" class="keyboard" role="group" aria-label="Bet≈±k"></div>
        <div class="actions">
          <button id="undoBtn" class="btn ghost" type="button">‚å´ Vissza egyet</button>
          <button id="clearBtn" class="btn ghost" type="button">Sor t√∂rl√©se</button>
        </div>
      </section>
    </main>

    <script>
      const alphabet = [
        'a','√°','b','c','cs','d','dz','dzs','e','√©','f','g','gy','h','i','√≠','j','k','l','ly','m','n','ny',
        'o','√≥','√∂','≈ë','p','q','r','s','sz','t','ty','u','√∫','√º','≈±','v','w','x','y','z','zs'
      ];

      let defaultWords = [];
      const fallbackWords = Array.isArray(window.HU_WORDS) ? window.HU_WORDS : [
        'alma','fa','h√°z','sz√©k','asztal','ceruza','f√ºzet','iskola','t√°ska','kocka','csiga','ny√∫l','l√≥','keny√©r','tej','vaj','t√≥','di√≥','v√≠z','t≈±z',
        '≈ëz','h√≥','sz√°r','sz≈ël≈ë','≈ësz','m√©z','h√≠d','felh≈ë','gomba','gyertya','k≈ë','gyerek','bar√°t','anya','apa','nagyi','kakas','ty√∫k','liba','r√≥ka',
        't√°ny√©r','kan√°l','villa','poh√°r','cs√©sze','k√©p','fal','polc','kert','vir√°g','r√≥zsa','erd≈ë','t√©l','ny√°r','tavasz','bolyg√≥','f≈±','≈±r','s≈±r≈±','t≈±',
        'lyuk','g√≥lya','zsir√°f','zseb','dzsem','dzsungel','feny≈ë','borj√∫','zsalu','gyufa','k√∂d','feladat','sz√≥da','r√≥mai','b√©ka','csapat','meggy','sz√©l','edz√©s'
      ];
      let customWords = [];

      const toggleGrid = document.getElementById('toggleGrid');
      const keyboard = document.getElementById('keyboard');
      const slotsEl = document.getElementById('slots');
      const statusEl = document.getElementById('status');
      const lengthTag = document.getElementById('lengthTag');
      const speakBtn = document.getElementById('speakBtn');
      const generateBtn = document.getElementById('generateBtn');
      const undoBtn = document.getElementById('undoBtn');
      const clearBtn = document.getElementById('clearBtn');
      const resetSelectionBtn = document.getElementById('resetSelection');
      const clearSelectionBtn = document.getElementById('clearSelection');
      const revealBtn = document.getElementById('revealBtn');
      const customTextArea = document.getElementById('customList');
      const customStatus = document.getElementById('customStatus');
      const wordFileInput = document.getElementById('wordFile');
      const applyCustomBtn = document.getElementById('applyCustom');
      const clearCustomBtn = document.getElementById('clearCustom');
      const storageKey = 'huLetterChoice';
      const maxLengthInput = document.getElementById('maxLength');
      const maxLengthDisplay = document.getElementById('maxLengthDisplay');
      const maxLengthStorageKey = 'huMaxWordLength';
      const maxLengthBounds = { min: 2, max: 20 };
      const defaultMaxWordLength = 12;

      let selectedLetters = new Set(alphabet);
      let currentWord = '';
      let currentTokens = [];
      let guess = [];
      let maxWordLength = defaultMaxWordLength;
      let cachedVoice = null;

      function resetRoundState() {
        currentWord = '';
        currentTokens = [];
        guess = [];
        renderSlots();
        speakBtn.disabled = true;
        revealBtn.disabled = true;
      }

      function splitIntoLetters(word) {
        const lower = word.toLowerCase();
        const tokens = [];
        let i = 0;
        while (i < lower.length) {
          if (lower.startsWith('dzs', i)) { tokens.push('dzs'); i += 3; continue; }
          const pair = lower.slice(i, i + 2);
          if (['cs','dz','gy','ly','ny','sz','ty','zs'].includes(pair)) { tokens.push(pair); i += 2; continue; }
          tokens.push(lower[i]);
          i += 1;
        }
        return tokens;
      }

      function normalizeWordList(raw) {
        if (!raw) return [];
        let arr = [];
        try {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) arr = parsed;
        } catch {
          /* fall through to newline split */
        }
        if (!arr.length) arr = raw.split(/\r?\n/);
        return arr
          .map(v => (v == null ? '' : String(v)).trim().toLowerCase())
          .filter(Boolean);
      }

      function filterValidWords(list) {
        const seen = new Set();
        const valid = [];
        list.forEach(w => {
          const letters = splitIntoLetters(w);
          if (!letters.length) return;
          const ok = letters.every(ch => alphabet.includes(ch));
          if (!ok) return;
          if (seen.has(w)) return;
          seen.add(w);
          valid.push(w);
        });
        return valid;
      }

      function clampMaxWordLength(val) {
        const num = Number(val);
        if (!Number.isFinite(num)) return defaultMaxWordLength;
        return Math.min(maxLengthBounds.max, Math.max(maxLengthBounds.min, Math.round(num)));
      }

      function syncMaxLengthDisplay() {
        maxLengthDisplay.textContent = `${maxWordLength} bet≈±`;
        maxLengthInput.value = maxWordLength;
      }

      function loadMaxLength() {
        let fromStorage = defaultMaxWordLength;
        try {
          const raw = localStorage.getItem(maxLengthStorageKey);
          if (raw != null) {
            const parsed = clampMaxWordLength(parseInt(raw, 10));
            if (!Number.isNaN(parsed)) fromStorage = parsed;
          }
        } catch {}
        maxWordLength = clampMaxWordLength(fromStorage);
        syncMaxLengthDisplay();
      }

      function saveMaxLength() {
        try { localStorage.setItem(maxLengthStorageKey, String(maxWordLength)); } catch {}
      }

      function updateCustomStatus(text, tone = 'muted') {
        customStatus.textContent = text;
        customStatus.dataset.tone = tone;
      }

      function setCustomWords(raw, sourceLabel = 'sz√≥lista') {
        const normalized = normalizeWordList(raw);
        const valid = filterValidWords(normalized);
        customWords = valid;
        if (!valid.length) {
          updateCustomStatus('Nem tal√°ltam √©rv√©nyes sz√≥t. A be√©p√≠tett lista marad.', 'warn');
          return;
        }
        updateCustomStatus(`Bet√∂ltve ${valid.length} sz√≥ (${sourceLabel}). Kattints az ‚Äû√öj sz√≥ k√©r√©se‚Äù gombra.`, 'success');
      }

      function getWordPool() {
        return customWords.length ? customWords : defaultWords;
      }

      function loadDefaultWordsFromFile() {
        defaultWords = filterValidWords(fallbackWords);
        const label = Array.isArray(window.HU_WORDS) ? 'magyar_szavak/words.js (a TXT-b≈ël gener√°lva)' : 'be√©p√≠tett mini lista';
        updateStatus(`Bet√∂ltve ${defaultWords.length} sz√≥ (${label}).`, 'muted');
        generateBtn.disabled = !selectedLetters.size;
      }

      function loadSelection() {
        try {
          const raw = localStorage.getItem(storageKey);
          if (!raw) return;
          const arr = JSON.parse(raw);
          if (Array.isArray(arr)) {
            const valid = arr.filter(l => alphabet.includes(l));
            if (valid.length) selectedLetters = new Set(valid);
          }
        } catch {}
      }

      function saveSelection() {
        try { localStorage.setItem(storageKey, JSON.stringify([...selectedLetters])); } catch {}
      }

      function updateStatus(text, tone = 'muted') {
        statusEl.textContent = text;
        statusEl.dataset.tone = tone;
      }

      function renderToggles() {
        toggleGrid.innerHTML = '';
        alphabet.forEach(letter => {
          const label = document.createElement('label');
          label.className = 'toggle' + (selectedLetters.has(letter) ? ' active' : '');
          label.title = `Enged√©lyezett: ${letter.toUpperCase()}`;

          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = letter;
          input.checked = selectedLetters.has(letter);
          input.addEventListener('change', () => {
            if (input.checked) selectedLetters.add(letter);
            else selectedLetters.delete(letter);
            saveSelection();
            renderToggles();
            renderKeyboard();
            generateBtn.disabled = !selectedLetters.size;
          });

          const span = document.createElement('span');
          span.textContent = letter.toUpperCase();

          label.appendChild(input);
          label.appendChild(span);
          toggleGrid.appendChild(label);
        });
        generateBtn.disabled = !selectedLetters.size;
      }

      function renderKeyboard() {
        keyboard.innerHTML = '';
        const disabled = !currentTokens.length;
        alphabet.forEach(letter => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = letter.toUpperCase();
          btn.dataset.letter = letter;
          btn.disabled = disabled || !selectedLetters.has(letter) || guess.length >= currentTokens.length;
          btn.addEventListener('click', () => handleLetter(letter));
          keyboard.appendChild(btn);
        });
      }

      function renderSlots() {
        slotsEl.innerHTML = '';
        if (!currentTokens.length) {
          ['_','_','_','_'].forEach(val => {
            const span = document.createElement('span');
            span.className = 'slot';
            span.textContent = val;
            slotsEl.appendChild(span);
          });
          lengthTag.textContent = '0 bet≈±';
          renderKeyboard();
          return;
        }

        currentTokens.forEach((letter, idx) => {
          const span = document.createElement('span');
          span.className = 'slot';
          const val = guess[idx];
          span.textContent = val ? val.toUpperCase() : '_';
          if (val) {
            span.dataset.state = val === letter ? 'right' : 'wrong';
          }
          slotsEl.appendChild(span);
        });
        lengthTag.textContent = `${currentTokens.length} bet≈±`;
        renderKeyboard();
      }

      function pickWord(allowed, maxLen = maxWordLength) {
        const limit = clampMaxWordLength(maxLen || defaultMaxWordLength);
        const pool = getWordPool();
        const options = pool.filter(w => {
          const letters = splitIntoLetters(w);
          return letters.length && letters.length <= limit && letters.every(ch => allowed.has(ch));
        });
        if (!options.length) return null;
        if (options.length === 1) return options[0];
        let choice = options[Math.floor(Math.random() * options.length)];
        let tries = 0;
        while (choice === currentWord && tries < 4) {
          choice = options[Math.floor(Math.random() * options.length)];
          tries += 1;
        }
        return choice;
      }

      function startNewWord() {
        if (!getWordPool().length) {
          updateStatus('M√©g nincs sz√≥lista bet√∂ltve. V√°rj egy pillanatot, vagy adj meg saj√°t list√°t.', 'warn');
          return;
        }
        const allowed = new Set(selectedLetters);
        if (!allowed.size) {
          updateStatus('Nincs bekapcsolt bet≈±. V√°lassz ki legal√°bb egyet.', 'warn');
          currentWord = '';
          currentTokens = [];
          guess = [];
          renderSlots();
          speakBtn.disabled = true;
          revealBtn.disabled = true;
          return;
        }
        const word = pickWord(allowed, maxWordLength);
        if (!word) {
          updateStatus(`Nincs olyan sz√≥, ami ezekb≈ël a bet≈±kb≈ël √°ll √©s belef√©r a ${maxWordLength} bet≈±s limitbe. Kapcsold be m√©g n√©h√°nyat, vagy emeld a maxim√°lis hossz√°t.`, 'warn');
          currentWord = '';
          currentTokens = [];
          guess = [];
          renderSlots();
          speakBtn.disabled = true;
          revealBtn.disabled = true;
          return;
        }
        currentWord = word;
        currentTokens = splitIntoLetters(word);
        guess = [];
        speakBtn.disabled = false;
        revealBtn.disabled = false;
        updateStatus(`Tal√°ld ki! ${currentTokens.length} bet≈±b≈ël √°ll.`, 'muted');
        renderSlots();
      }

      function handleLetter(letter) {
        if (!currentTokens.length) {
          updateStatus('El≈ësz√∂r k√©rj egy √∫j sz√≥t!', 'warn');
          return;
        }
        if (guess.length >= currentTokens.length) return;
        guess.push(letter);
        renderSlots();
        if (guess.length === currentTokens.length) checkResult();
      }

      function checkResult() {
        const success = guess.every((l, i) => l === currentTokens[i]);
        if (success) {
          updateStatus('√úgyes! Minden bet≈± j√≥. K√©rj √∫j sz√≥t a k√∂vetkez≈ë k√∂rh√∂z.', 'success');
        } else {
          updateStatus('Van benne hiba. T√∂r√∂lj egyet, vagy kezdd √∫jra.', 'warn');
        }
      }

      function revealWord() {
        if (!currentWord || !currentTokens.length) {
          updateStatus('El≈ësz√∂r k√©rj egy √∫j sz√≥t, ut√°na tudod felfedni.', 'warn');
          return;
        }
        guess = [...currentTokens];
        renderSlots();
        updateStatus(`A sz√≥: ${currentWord.toUpperCase()}. K√©rj √∫j sz√≥t vagy t√∂r√∂ld a sort.`, 'success');
      }

      function undo() {
        if (!guess.length) return;
        guess.pop();
        renderSlots();
        updateStatus('√çrd be a k√∂vetkez≈ë bet≈±t!', 'muted');
      }

      function clearGuess() {
        if (!currentTokens.length) return;
        guess = [];
        renderSlots();
        updateStatus('Kezdd el√∂lr≈ël ugyanazt a sz√≥t.', 'muted');
      }

      function pickHungarianVoice(forceRefresh = false) {
        try {
          if (cachedVoice && !forceRefresh) {
            const lang = (cachedVoice.lang || '').toLowerCase();
            if (lang.startsWith('hu')) return cachedVoice;
          }
          const voices = speechSynthesis.getVoices();
          if (!voices || !voices.length) return null;
          const langHu = voices.find(v => (v.lang || '').toLowerCase().startsWith('hu'));
          if (langHu) return langHu;
          const nameHu = voices.find(v => (v.name || '').toLowerCase().includes('hungarian'));
          if (nameHu) return nameHu;
          const containsHu = voices.find(v => (v.lang || '').toLowerCase().includes('hu'));
          return containsHu || null;
        } catch { return null; }
      }

      function speakWord() {
        if (!currentWord) return;
        try {
          if (!('speechSynthesis' in window)) return;
          window.speechSynthesis.cancel();
          const utter = new SpeechSynthesisUtterance(currentWord);
          const voice = pickHungarianVoice(true);
          if (voice) {
            cachedVoice = voice;
            utter.voice = voice;
            utter.lang = voice.lang || 'hu-HU';
          } else {
            utter.lang = 'hu-HU'; // force Hungarian accent even if no specific voice is installed
            updateStatus('Nem tal√°ltam magyar hangot a b√∂ng√©sz≈ëben. Telep√≠ts magyar TTS hangot a rendszerbe a pontos kiejt√©shez.', 'warn');
          }
          utter.rate = 0.95;
          utter.pitch = 1.0;
          speechSynthesis.speak(utter);
        } catch {}
      }

      // Init
      loadMaxLength();
      loadSelection();
      renderToggles();
      renderKeyboard();
      loadDefaultWordsFromFile();
      generateBtn.addEventListener('click', startNewWord);
      speakBtn.addEventListener('click', speakWord);
      undoBtn.addEventListener('click', undo);
      clearBtn.addEventListener('click', clearGuess);
      revealBtn.addEventListener('click', revealWord);
      resetSelectionBtn.addEventListener('click', () => {
        selectedLetters = new Set(alphabet);
        saveSelection();
        renderToggles();
        renderKeyboard();
        generateBtn.disabled = false;
      });
      clearSelectionBtn.addEventListener('click', () => {
        selectedLetters = new Set();
        saveSelection();
        renderToggles();
        renderKeyboard();
        generateBtn.disabled = true;
        updateStatus('Minden bet≈± kikapcsolva. Kapcsold be, majd k√©rj √∫j sz√≥t.', 'warn');
      });
      applyCustomBtn.addEventListener('click', () => {
        setCustomWords(customTextArea.value, 'sz√∂veg');
        resetRoundState();
        if (customWords.length) {
          updateStatus('Saj√°t sz√≥lista bet√∂ltve. Kattints az ‚Äû√öj sz√≥ k√©r√©se‚Äù gombra.', 'muted');
        } else {
          updateStatus('Nem siker√ºlt bet√∂lteni a saj√°t list√°t, a be√©p√≠tett marad.', 'warn');
        }
      });
      clearCustomBtn.addEventListener('click', () => {
        customWords = [];
        updateCustomStatus('Visszat√©rt√©l a be√©p√≠tett szavakhoz.', 'muted');
        resetRoundState();
        updateStatus('Gy√°ri sz√≥lista akt√≠v. Kattints az ‚Äû√öj sz√≥ k√©r√©se‚Äù gombra.', 'muted');
      });
      wordFileInput.addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const text = String(reader.result || '');
          customTextArea.value = text;
          setCustomWords(text, file.name);
          resetRoundState();
          if (customWords.length) {
            updateStatus('F√°jlb√≥l bet√∂lt√∂tt lista akt√≠v. Kattints az ‚Äû√öj sz√≥ k√©r√©se‚Äù gombra.', 'muted');
          } else {
            updateStatus('Nem siker√ºlt √©rv√©nyes szavakat tal√°lni ebben a f√°jlban. A gy√°ri lista marad.', 'warn');
          }
        };
        reader.readAsText(file);
      });
      maxLengthInput.addEventListener('input', (e) => {
        const previous = maxWordLength;
        maxWordLength = clampMaxWordLength(parseInt(e.target.value, 10));
        syncMaxLengthDisplay();
        saveMaxLength();
        if (currentTokens.length && currentTokens.length > maxWordLength) {
          resetRoundState();
          updateStatus('Cs√∂kkentetted a max sz√≥hosszt. K√©rj √∫j sz√≥t az √∫j korl√°ttal.', 'warn');
        } else if (maxWordLength !== previous && !currentTokens.length) {
          updateStatus(`Legfeljebb ${maxWordLength} bet≈±s szavakat kapsz. Kattints az ‚Äû√öj sz√≥ k√©r√©se‚Äù gombra.`, 'muted');
        }
      });
      if ('speechSynthesis' in window) {
        const warmVoices = (retries = 4) => {
          pickHungarianVoice(true);
          const hasVoices = speechSynthesis.getVoices().length;
          if (!hasVoices && retries > 0) {
            setTimeout(() => warmVoices(retries - 1), 200);
          }
        };
        window.speechSynthesis.addEventListener('voiceschanged', () => {
          cachedVoice = pickHungarianVoice(true);
        });
        warmVoices();
      }
    </script>
  </body>
</html>
